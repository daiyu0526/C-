//C语言学习练习题中的值得记录知识点

// 1.求解1-1/2+1/3-...+1/n

#include<stdio.h>
int main(void)
{
	double sum = 0.0;            //浮点型在初始化时，数字需带上小数点来表示
	int i,number, sign = 1;

	scanf_s("%d", &number);
	for (i = 1; i <= number; i++)
	{
		sum += sign * 1.0 / i;       //这里i为整形数据，但前面都是浮点型数据，再进行整型转化至浮点型时常用乘1.0
                sign = -sign;                //题目这里的变号比较巧
	}
	printf("sum=%f\n", sum);
	return 0;
}







//2.正序地分解整数 例：输入12345；输出：1 2 3 4 5

#include<stdio.h>
int main(void)
{
	int number, d = 0, ret = 0,b=0;

	scanf_s("%d", &number);
	do 
	{
		d = number % 10;
		number = number / 10;
		ret = ret * 10 + d;
	} while (number > 0);
	printf("%d", ret);
	printf("\n");                   //这个代码将数进行一次倒序
	                                //而后在下一个while循环中进行倒序逐个输出，可得最终结果
	do                              //这里是一个替代转向思维，有的无法直接解决的问题，我们可用别的问题再转换
	{                               //但这个问题无法将700转化为007
		b = ret % 10;           // **在if语句中经常将这个赋值符号=与判断符号==搞混
		printf("%d", b);
		if (ret > 9) 
		{
			printf(" ");
		}
		ret = ret / 10;
	} while (ret > 0);
	printf("\n");

	return 0;
}                        


//针对上述问题中无法适用于末尾有0的数字，则对上述代码再次实行更改

#include<stdio.h>
int main(void)
{
	int number, base = 1, d = 0, x = 0;                                //这里包含了两个部分 数整数位数+正序输出  有很多问题都是由小的问题进行组合解决的
	scanf_s("%d", &number);                                            //数位数是为了能够形成，例如：54321，得到：10000，再除再取余可进行
	x = number;                                                        
	if (number == 0)                      //在进行if语句判断时经常将==与赋值的=搞混
	{
		base = 0;                     //0是一个一位数，因此这里单独列出
		printf("base=%d\n", base);
	}
	else
	{
		while (number > 9)            //************number的不断条件是大于9，不是大于0，若是大于0，则会出现number=700，base=1000的情况
		{
			number = number / 10;
			base *= 10;           //************
		}
		printf("base=%d\n", base);
	}                                     //以上这里都是数整数位数的地方，同时得到了进制基数
	
	do                                    //这里是进行了整数顺序输出，这里也可以用while不用do—while
	{
		d = x / base;                 //这里得到正的第一位数
		printf("%d",d);               //输出
		if (base > 9)                 //这里将整数的每一位都分开
		{
			printf(" ");
		}
		x %= base;
		base /= 10;                   
	} while (base > 0);
	printf("\n");
	return 0;	
}







//计算机在计算一些基础问题时常爱用枚举法
//scanf_s在输入多个数字时，代码中可以不用空格隔开，可以写成scanf_s("%d%d", &u, &v); 但在输入时只能用空格隔开
//3.计算最大公约数 **************这里是枚举法

#include<stdio.h>                              //这是我的代码，这里也是运用到之前学的小方法来设置了一下变量
int main(void)                                 //这个没设最小值，但是运用了&&符号也可以保证t不会大于两个数中的任意一个
{
	int u, v, t = 2, x = 0;
	scanf_s("%d%d", &u, &v);
	while (u >= t && v >= t) 
	{
		if (u % t == 0 && v % t == 0) 
		{
			x = t;
		}
		t++;
	}
	if (x == 0)
	{
		printf("两个数无最大公约数");
	}
	else
	{
		printf("最大公约数%d", x);
	}
	return 0;	
}

#include<stdio.h>                               //老师的代码，运用了for循环且判断语句用if执行
int main(void)
{
	int u, v, min, i, ret;
	scanf("%d%d", u, v);
	if (u > v)
	{
		min = u;
	}
	else
	{
		min = v;
	}
	for (i = 1; i < min; i++) 
	{
		if (u % i == 0) 
		{
			if (v % i == 0) 
			{
				ret = i;
			}
		}
	}
	printf("%d", ret);
	return 0;	
}

//************以上两种方法效率低，所以这里用辗转相除法
//************辗转相除法的原理：又称欧几里得算法，是求取最大公约数的一种算法。核心原理：两个数的最大公约数等于其中较小的数字和二者之间余数的最大公约数
//************具体做法：用较小数除较大数，再用出现的余数（第一余数）去除除数，再用出现的余数（第二余数）去除第一余数，如此反复，直到最后余数是0为止。
                        如果是求两个数的最大公约数，那么最后的除数就是这两个数的最大公约数。整数在「加减乘」这三种运算下是封闭的
//************辗转相除法的具体证明查网络，gcd是最大公约数的缩写

#include<stdio.h>
int main(void)
{
	int a, b, t;
	scanf_s("%d%d", &a, &b);
	do
	{
		t = a % b;
		a = b;
		b = t;
	} while (b != 0);
	printf("%d", a);
	return 0;	
}








//4.给定不超过6的正整数a，考虑从a开始的连续4个数字，输出所有由其组成的无重复数字的3位数
//************格式要求：输入为2  输出为 234 235 243 245 253 254
                                        324 325 342 345 352 354  
					.....
					.....
#include<stdio.h>
int main(void)
{
	int a, i, j, k, n = 0;

	scanf_s("%d", &a);
	i = a;
	while (i <= a + 3) 
	{
		j = a;
		while (j <= a + 3) 
		{
			k = a;
			while (k <= a + 3) 
			{
				if (i != j) 
				{
					if (i != k) 
					{
						if (j != k) 
						{
							printf("%d%d%d ", i, j, k);
							n++;
							if (n % 6 == 0) 
							{
								printf("\n");
							}
						}
					}
				}
				k++;
			}
			j++;
		}
		i++;
	}
	return 0;	
}
//**************重点这里设置了三重循环用于不断地递增获得重组数字，但该遍历会出现重复数字的情况，因此
//**************这里加上了三个if语句用于消除这个问题，这种遍历与枚举是计算机最擅长做的事情。
//**************同时，此例也可以用if语句来书写，两个代码的对比可以看出while和for在相互转换时的方式

#include<stdio.h>
int main(void)
{
	int a, i, j, k;

	scanf_s("%d", &a);
	for (i = a; i <= a + 3; i++) 
	{
		for (j = a; j <= a + 3; j++) 
		{
			for (k = a; k <= a + 3; k++) 
			{
				if (i != j && i != k && j != k) 
				{
					printf("%d%d%d ", i, j, k);       //************从这里可以看出for函数的三个关系式是如何用，详见笔记
				}
			}
		}
	}
	return 0;	
}





//5.浮点数的精度确定

#include<stdio.h>
int main(void)
{
	printf("%.3f\n", -0.0049);
	printf("%.30f\n", -0.0049);
	printf("%.3f\n", -0.00049);
	return 0;
}
输出结果：                         //重点：这里可以看出对于浮点数，计算机没有办法到达像整数那样的精度，只能找到一个近似的数
-0.005                            //同时，double有十七位有效数字，则在17位开外的数字的有效性是不一定的。但在执行窗口处我们一般只显示小数点后6位，需要更多在printf里写
-0.004899999999999999841793218991
-0.000

//逃逸字符/b的运用
#include<stdio.h>
int main(void)
{
	printf("123\bAB\n456\n");
	return 0;
}
输出结果：
12AB  //可以看出这里的\b是把原先的数字回退后贴上有输出的字符
456

//逃逸字符/t制表字符的运用
#include<stdio.h>
int main(void)
{
	printf("123\t456\n");
	printf("12\t456\n");
	return 0;
}
输出结果：
123     456       //制表位是在每行的固定位置的，一个\t使得输出从下一个制表位开始，使用这个才能使得上下对齐
12      456

//强制类型转换
#include<stdio.h>
int main(void)
{
	int i = 32768;
	short s = (short)i;
	printf("%d,%d", i,s);    //强制转换只是从哪个变量中计算出一个新的变量，无论是值还是变量类型（i）都不变的
	return 0;
}
输出结果：
32768,-32768      //这里将i强制转换给了s，但是i原本的值并没有变

//变量类型问题
#include<stdio.h>
int main(void)
{
	double a = 1.0;
	double b = 2.1;
	int i = a + b;
	printf("%d", i);
	return 0;
}
//输出结果：3     类型不同时进行精度的计算时会导致一些数的流失，导致精度下降




//6.取地址运算&

#include<stdio.h>
int main(void)
{
	int i = 0;
	printf("0x%x\n", &i);                 //x表示16进制输出
	printf("%p\n", &i);                   //输出变量地址
	printf("%lu\n", sizeof(int));         //在64位上int是4字节，Long unsigned数据类型无符号长整数或无符号长浮点数
	printf("%lu\n", sizeof(&i));          //但是地址是8个字节
	return 0;
}
输出结果：
0x28ff754
00000076028FF754   //此处两个取地址之所以不一样是因为这个电脑的架构是64位的，当时32位的时候是一样的
4                  //这两个数据类型不一样，地址和数据的类型不同则会导致输出不同，所以在输出地址时我们应该使用%p进行
8



//函数的一些知识点
1、函数的递归：函数是C语言的模块，有较强的独立性，可相互调用。可在函数A中调用函数B，也可在函数B中调用函数C，调用函数自身称为递归。
2、main函数是整个程序的入口，因此我们一般将编写的函数放在后面，将main放在前面，但是我们这样是需要将其进行声明。
3、 C语言为我们提供了上百个可调用的库函数，例如与字符串有关的strlen,strcat,strlwr，或是我们刚接触C语言时候用到的printf,scanf,这些都是c语言为我们提供的。
    在我们使用某一库函数的时候，需要在程序中嵌入(#include<>) 该函数所需要的头文件。
    因此我们在代码开头都需要写上#include <stdio.h>，因为 printf, scanf，getchar,gets,putchar()这些函数 (也称作标准I/O函数)，都是在stdio头文件中。
4、函数按照是否有参数分为有参类型和无参类型，按照是否有返回值也分为有返回值和无返回值两种类型。
5、有参与无参区分：有参函数：在该函数被调用的时候，主调函数通过参数向里面传递了数据；无参函数：不传递数据，因没有参数，无法获得值。

函数的定义和声明
1、形式 :
       函数类型   函数名(参数表)
       参数说明
       {
           数据说明
           执行语句
       }
2、函数调用
调用函数的时候，需要知道以下几点：
  1：在调用的时候，主调函数向参数传递的是值，在调用结束后，该值不改变。
     函数再调用的时候，发生的是值传递，也就是把值拷贝一份给形参，在形参里面改变这一数值，即在调用函数中改变数值，并不影响实参的值（这里的值是单向传递的：实参 -> 形参）
  2：函数只有被调用，系统才会给它分配内存单元。
  3：调用结束后，系统给他分配的内存单元立即被释放，而主调函数中的值不会改变
  4：主调函数传递给被调用函数值后，被调用的函数里面可以直接用该值，但是要记住，值的数据类型要和参数的数据类型一一对应。
     在数据传递的时候，若是数据类型不同，有可能会发生数据丢失等错误，调用函数时给的值与参数的类型必须匹配。
  5：可以彻底给被调函数的值是表达式的结果，包括：字面量、变量、函数的返回值、计算的结果。
  6：函数调用时有两种方式：传值调用 与 传址调用（在某些情况下我们要使用不同的方法，例子见其下）


3、函数知识点编写时发现的点

3.1
#include<stdio.h>
int max(int a,int b)               //这里是编写的求取max的函数，注意我们需要将求得的值返回给main函数，因此这里是要设定函数类型为int，不能为void
{
        int max;                  //从中可看出在这里其实也是可以再定义变量的，在函数头列出的是main传给该函数的参数表，是用来计算的值在这里体现，
	if (a >= b)                 但是在实际的函数运行中所使用别的变量也是可以再定义的
	{
		 max = a;         //这里更为简便的方法是直接传递a的值过去即可，不需要在进行一次max的赋值，else处也是
		return max;
	}
	else 
	{
		 max = b;
		return max;
	};
}
int main(void)
{
	int a=max(4,6);          //定义时直接顺便赋值
	printf("%d", a);
	return 0;
}

3.1返回值return
#include<stdio.h>
void swap(int a, int b);            //从结果可知a与b并没有交换
int main() 
{
	int a = 5;
	int b = 6;
	swap(a, b);
	printf("a%d,b%d", a, b);
	return 0;
}
void swap(int a, int b)             //这里函数设为void形式，没有返回值return
{                                    1、return 语句的一般形式为：return （表达式） 有无括号都是正确的
        int x = a;                   2、没有返回值的函数为空类型，用void表示
	a = b;                             3、return 语句可以有多个，可以出现在函数体的任意位置，但是每次调用函数只能有一个 return 语句被执行，所以只有一个返回值。
	b = x;                             4、函数一旦遇到 return 语句就立即返回，后面的所有语句都不会被执行到了。return 语句还有强制结束函数执行的作用。
}                                    5、这个交换数据的题目，对应了调用函数的第一点，发生值传递时，我们是将数值拷贝一份给调用函数内，在调用函数内改变数据，不会影响实参的
结果：a5，b6                            数值的，因此这里并没有交换
                                     6、其次在该代码中，在main中我们已经使用过名字为a、b的变量了，但是又可以在swap函数中再次使用
																		
3.2
