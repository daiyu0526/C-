//C语言学习练习题中的值得记录知识点
***********************************************************************************************************************************************************************
自己编写时常出的错误
1、if判断语句中的 == 判断符号老是写为赋值号 = 

***********************************************************************************************************************************************************************
// 1.求解1-1/2+1/3-...+1/n
#include<stdio.h>
int main(void)
{
	double sum = 0.0;            //浮点型在初始化时，数字需带上小数点来表示
	int i,number, sign = 1;

	scanf_s("%d", &number);
	for (i = 1; i <= number; i++)
	{
		sum += sign * 1.0 / i;       //这里i为整形数据，但前面都是浮点型数据，再进行整型转化至浮点型时常用乘1.0
                sign = -sign;                //题目这里的变号比较巧
	}
	printf("sum=%f\n", sum);
	return 0;
}
***********************************************************************************************************************************************************************
//2.正序地分解整数 例：输入12345；输出：1 2 3 4 5
#include<stdio.h>
int main(void)
{
	int number, d = 0, ret = 0,b=0;

	scanf_s("%d", &number);
	do 
	{
		d = number % 10;
		number = number / 10;
		ret = ret * 10 + d;
	} while (number > 0);
	printf("%d", ret);
	printf("\n");                   //这个代码将数进行一次倒序
	                                //而后在下一个while循环中进行倒序逐个输出，可得最终结果
	do                              //这里是一个替代转向思维，有的无法直接解决的问题，我们可用别的问题再转换
	{                               //但这个问题无法将700转化为007
		b = ret % 10;           // **在if语句中经常将这个赋值符号=与判断符号==搞混
		printf("%d", b);
		if (ret > 9) 
		{
			printf(" ");
		}
		ret = ret / 10;
	} while (ret > 0);
	printf("\n");

	return 0;
}                        
***********************************************************************************************************************************************************************
//针对上述问题中无法适用于末尾有0的数字，则对上述代码再次实行更改

#include<stdio.h>
int main(void)
{
	int number, base = 1, d = 0, x = 0;                                //这里包含了两个部分 数整数位数+正序输出  有很多问题都是由小的问题进行组合解决的
	scanf_s("%d", &number);                                            //数位数是为了能够形成，例如：54321，得到：10000，再除再取余可进行
	x = number;                                                        
	if (number == 0)                      //在进行if语句判断时经常将==与赋值的=搞混
	{
		base = 0;                     //0是一个一位数，因此这里单独列出
		printf("base=%d\n", base);
	}
	else
	{
		while (number > 9)            //************number的不断条件是大于9，不是大于0，若是大于0，则会出现number=700，base=1000的情况
		{
			number = number / 10;
			base *= 10;           //************
		}
		printf("base=%d\n", base);
	}                                     //以上这里都是数整数位数的地方，同时得到了进制基数
	
	do                                    //这里是进行了整数顺序输出，这里也可以用while不用do—while
	{
		d = x / base;                 //这里得到正的第一位数
		printf("%d",d);               //输出
		if (base > 9)                 //这里将整数的每一位都分开
		{
			printf(" ");
		}
		x %= base;
		base /= 10;                   
	} while (base > 0);
	printf("\n");
	return 0;	
}

***********************************************************************************************************************************************************************
//计算机在计算一些基础问题时常爱用枚举法
//scanf_s在输入多个数字时，代码中可以不用空格隔开，可以写成scanf_s("%d%d", &u, &v); 但在输入时只能用空格隔开
//3.计算最大公约数 **************这里是枚举法
#include<stdio.h>                              //这是我的代码，这里也是运用到之前学的小方法来设置了一下变量
int main(void)                                 //这个没设最小值，但是运用了&&符号也可以保证t不会大于两个数中的任意一个
{
	int u, v, t = 2, x = 0;
	scanf_s("%d%d", &u, &v);
	while (u >= t && v >= t) 
	{
		if (u % t == 0 && v % t == 0) 
		{
			x = t;
		}
		t++;
	}
	if (x == 0)
	{
		printf("两个数无最大公约数");
	}
	else
	{
		printf("最大公约数%d", x);
	}
	return 0;	
}
***********************************************************************************************************************************************************************
#include<stdio.h>                               //老师的代码，运用了for循环且判断语句用if执行
int main(void)
{
	int u, v, min, i, ret;
	scanf("%d%d", u, v);
	if (u > v)
	{
		min = u;
	}
	else
	{
		min = v;
	}
	for (i = 1; i < min; i++) 
	{
		if (u % i == 0) 
		{
			if (v % i == 0) 
			{
				ret = i;
			}
		}
	}
	printf("%d", ret);
	return 0;	
}
***********************************************************************************************************************************************************************
//************以上两种方法效率低，所以这里用辗转相除法
//************辗转相除法的原理：又称欧几里得算法，是求取最大公约数的一种算法。核心原理：两个数的最大公约数等于其中较小的数字和二者之间余数的最大公约数
//************具体做法：用较小数除较大数，再用出现的余数（第一余数）去除除数，再用出现的余数（第二余数）去除第一余数，如此反复，直到最后余数是0为止。
                        如果是求两个数的最大公约数，那么最后的除数就是这两个数的最大公约数。整数在「加减乘」这三种运算下是封闭的
//************辗转相除法的具体证明查网络，gcd是最大公约数的缩写
#include<stdio.h>
int main(void)
{
	int a, b, t;
	scanf_s("%d%d", &a, &b);
	do
	{
		t = a % b;
		a = b;
		b = t;
	} while (b != 0);
	printf("%d", a);
	return 0;	
}
***********************************************************************************************************************************************************************
//4.给定不超过6的正整数a，考虑从a开始的连续4个数字，输出所有由其组成的无重复数字的3位数
//************格式要求：输入为2  输出为 234 235 243 245 253 254
                                        324 325 342 345 352 354  
					.....
					.....
#include<stdio.h>
int main(void)
{
	int a, i, j, k, n = 0;

	scanf_s("%d", &a);
	i = a;
	while (i <= a + 3) 
	{
		j = a;
		while (j <= a + 3) 
		{
			k = a;
			while (k <= a + 3) 
			{
				if (i != j) 
				{
					if (i != k) 
					{
						if (j != k) 
						{
							printf("%d%d%d ", i, j, k);
							n++;
							if (n % 6 == 0) 
							{
								printf("\n");
							}
						}
					}
				}
				k++;
			}
			j++;
		}
		i++;
	}
	return 0;	
}
//**************重点这里设置了三重循环用于不断地递增获得重组数字，但该遍历会出现重复数字的情况，因此
//**************这里加上了三个if语句用于消除这个问题，这种遍历与枚举是计算机最擅长做的事情。
//**************同时，此例也可以用if语句来书写，两个代码的对比可以看出while和for在相互转换时的方式
**********************************************************************************************************************************************************************
#include<stdio.h>
int main(void)
{
	int a, i, j, k;

	scanf_s("%d", &a);
	for (i = a; i <= a + 3; i++) 
	{
		for (j = a; j <= a + 3; j++) 
		{
			for (k = a; k <= a + 3; k++) 
			{
				if (i != j && i != k && j != k) 
				{
					printf("%d%d%d ", i, j, k);       //************从这里可以看出for函数的三个关系式是如何用，详见笔记
				}
			}
		}
	}
	return 0;	
}
********************************************************************************************************************************************************************
//5.浮点数的精度确定
#include<stdio.h>
int main(void)
{
	printf("%.3f\n", -0.0049);
	printf("%.30f\n", -0.0049);
	printf("%.3f\n", -0.00049);
	return 0;
}
输出结果：                         //重点：这里可以看出对于浮点数，计算机没有办法到达像整数那样的精度，只能找到一个近似的数
-0.005                            //同时，double有十七位有效数字，则在17位开外的数字的有效性是不一定的。但在执行窗口处我们一般只显示小数点后6位，需要更多在printf里写
-0.004899999999999999841793218991
-0.000
***********************************************************************************************************************************************************************
//逃逸字符/b的运用
#include<stdio.h>
int main(void)
{
	printf("123\bAB\n456\n");
	return 0;
}
输出结果：
12AB  //可以看出这里的\b是把原先的数字回退后贴上有输出的字符
456
**********************************************************************************************************************************************************************
//逃逸字符/t制表字符的运用
#include<stdio.h>
int main(void)
{
	printf("123\t456\n");
	printf("12\t456\n");
	return 0;
}
输出结果：
123     456       //制表位是在每行的固定位置的，一个\t使得输出从下一个制表位开始，使用这个才能使得上下对齐
12      456
**********************************************************************************************************************************************************************
//强制类型转换
#include<stdio.h>
int main(void)
{
	int i = 32768;
	short s = (short)i;
	printf("%d,%d", i,s);    //强制转换只是从哪个变量中计算出一个新的变量，无论是值还是变量类型（i）都不变的
	return 0;
}
输出结果：
32768,-32768      //这里将i强制转换给了s，但是i原本的值并没有变
*********************************************************************************************************************************************************************
//变量类型问题
#include<stdio.h>
int main(void)
{
	double a = 1.0;
	double b = 2.1;
	int i = a + b;
	printf("%d", i);
	return 0;
}
//输出结果：3     类型不同时进行精度的计算时会导致一些数的流失，导致精度下降
**********************************************************************************************************************************************************************
//6.取地址运算&     作用：获取变量的地址，其操作数必须是变量
#include<stdio.h>
int main(void)
{
	int i = 0;
	printf("0x%x\n", &i);                 //x表示16进制输出
	printf("%p\n", &i);                   //输出变量地址，这个%p是输出地址的表达，但是后面输出的数据也还是需要&的
	printf("%lu\n", sizeof(int));         //在64位上int是4字节，Long unsigned数据类型无符号长整数或无符号长浮点数
	printf("%lu\n", sizeof(&i));          //但是地址是8个字节，取得地址的大小也可以用sizeof来计算其长度
	return 0;
}
输出结果：
0x28ff754
00000076028FF754   //此处两个取地址之所以不一样是因为这个电脑的架构是64位的，当时32位的时候是一样的，地址的大小是否与int相同取决于编译器
4                  //这两个数据类型不一样，地址和数据的类型不同则会导致输出不同，所以在输出地址时我们应该使用%p进行
8

注意：1、&不能对没有地址的东西进行取值，例如：&（a+b);&(a++);&(++a) 这种可以在输出的时候直接输出，但是不能进行输出地址，因为a++类似的是对变量内的值进行运算，不是地址

7、指针*
   引入该概念：如果能够将取得的变量的地址传递给一个函数，能否通过这个地址来访问这个变量，例如：scanf（我们也是传入了一个地址，该函数就用该地址去寻找到了这个变量）
               则什么类型能够接受取地址得到的类型数据呢？指针
注意：1、指针类型的变量就是保存地址的变量，保存&a得到的值。例如：*p = &i ;则其中，p保存的就是i所在的地址，为什么要加上一*构造一个全新的变量类型，因为我们上述说过了，地址
         和数据类型会根据电脑的不同来导致输出不同，所以我们需要新定义一种类型。对这个语句，我们常说，p这个指针现在指向i。实际上就是指p这里面现在有i的地址。
      2、int* p,q;
         int *p,q;    //这两句语句表达的意思相同，无所谓指针靠近谁，这是代表p是一个指针变量，而q是一个int整型变量
      3、指针变量内的值是具有实际值得变量的地址；
         普通变量内的值是实际的值
      4、指针作为函数的参数时，在函数调用时我应该对这个函数输一个地址，变量的地址
      5、*是一个单目运算符，用来访问指针上的值所表示的地址上的变量，*p可以做右值也可以做左值（左值是指出现在复制号左边的不是变量而是值，例：*p=3；这里*p绝对也有值的）
			
例子：练习并验证指针
#include<stdio.h>
int main() 
{
	int i = 6;
	int* p = &i;           //这里的初始化时赋值地址的
	printf("%x\n", &i);    //输出i的地址
	printf("%p\n", &i);    //输出i的地址
	printf("%x\n", p);     //输出i的地址，p作为一个指针，里面存的是i的地址
	printf("%p\n", p);     //输出i的地址，但其结果因输出格式不同于上一个呈现不同
	printf("%d\n", *p);    //*p指针是表示p内表示的地址指向的位置里面的值是多少，也就是说 *p 与 i 其实是代表同一个变量，改了其中一个另一个就变
}
输出结果：
8836f604
000000198836F604
8836f604
000000198836F604
6
**********************************************************************************************************************************************************************
指针的运算符 & 与 * （这两个运算符互为相反数）
1、*&a = *(&a) = *(a的地址) = a                           // & 的作用是去这个变量的地址，* 是取这个地址栏指向的位置里的数
2、&*a = &(*a) = &(a内的地址值所指向的变量内的值) = a      //由此可以看出 & * 这两个运算符的作用正好相反，作用不分前后

指针运用场景一：写一个函数来交换两个数
#include<stdio.h>
int swap();
int main() 
{
	int a, b;
	scanf_s("%d %d", &a, &b);
	swap(&a, &b);                                        //这里在写时加上了int是不对的，在main里面调用函数的时候只需要将需要的参数写进去就好，不用写明数据类型
	printf("%d %d", a, b);                               //这个地方用的swap就是一个传址的问题，这里将a与b的地址传入了
	return 0;
}
int swap(int* p, int* q)                               //这里定义函数时，参数表明了其为一个地址数据
{
	int t;
	t = *p;      
	*p = *q;                                      //这里一开始写的是  &*p = &*q（错误的），因为*p表示的就是原来的变量，要是加上取地址符号，那么得到的就是a与b的地址了
	*q = t;
	return 0;
}

指针运用场景二：函数需要返回多个值，则某些值就只能通过指针来返回，也就是说可以让传入的参数为地址，保存一下待会的结果的变量
我的代码
#include<stdio.h>                                           //这个代码好奇怪，在minmax函数还未声明时就可以正常运行了？！
int main() 
{
	int a[] = { 1,2,3,4,5,6,7,8,9,12,13,14,16,17,21,58,55 };  //这里将a改为b也是可以正常运行代码的
	minmax(a);                                                //这里将数组作为参数输入的时候是不能填上[]的
	printf("%d %d\n", a[0], a[1]);
}
int minmax(int b[])
{
	int i = 1;
	int max = b[0], min = b[0];                               //这里是遍历找寻最大最小数值，因此一定要进行先赋值后再逐个对比
	while (i < 17)
	{
		if (b[i] >= max)                                        //这里i+1与i++是不一样的
		{
			max = b[i];                               //其实这里这样写是不对的，是正好这个参数正好是数组，所以其变量名是地址可以更改，但是别的是不可以的
		}                                                   这个问题详见420
		if (b[i] <= min)
		{
			min = b[i];
		}
		i++;
	}
	b[0] = max;
	b[1] = min;
}


这个minmax函数的改进写法
void minmax(int a[], int len, int *min, int *max)            //这里的max与min是在主函数中已经设好了的同名变量，根据变量的有限空间可知，可以在main和minmax中使用同名变量
{                                                            //我们在这里设这两个是个指针函数的，在main函数里面要给&min才对
   int i;                                                    //这里再main函数中必须设置一个不用变量，将其作为参数输入进函数中记录函数运算结果
	 *min = *max = a[0];
	 for(i = 0; i<len; i++)
	 {
	    if(a[i]<*min)
			{
			   *min=a[i];
			}
			if(a[i]>*max)
			{
			   *max=a[i];
			}
 }
 指针运用场景二b
*return返回运算状态（判断函数运算是否出错），指针返回运算运算结果
*在使用指针时一定要记得初始化，不然指针*p内就是一组乱码，乱码代表的是计算机内的一个位置，当再写 *p = 12 时，我们就得是将这随便的一个地址内的值改为了12.这个和之前说*p本质上
 代表的是这个变量名的想法是一致的。
***********************************************************************************************************************************************************************
单字符输入输出用putchar于getchar
1、putchar: int putchar(int c); 向标准输出里面写一个字符，返回写了几个字符，EOF(-1)表示写失败
2、getchar: int getchar(void); 从标准输入读入一个字符，返回类型是为了返回EOF（输入结束）所以是int型，这两个都是只能一次输入一个字符，所以在使用时得用循环语句

字符串要用到其处理函数时，得写#include<string.h>
1、strlen，计算字符串的长度，使用格式：string（数组名）
2、strcmp, 比较两个字符串是否相等，甚至可以设置具体哪个大，使用格式：strcmp（s1，s2）
3、strcpy, 拷贝字符串，使用格式：strcpy
***********************************************************************************************************************************************************************
问：调用函数时将数组输入调用函数的参数时，调用函数将这个数组参数如何处理了？
答：实际上作为参数输入调用函数中的数组是一个指针。所以我们在整个参数位置上的数组中不能写个数（例如：int maxmin(int a[], int length, int *min, int *max)），为什么在这里不能
    用sizeof求取a[]的字节数，原因就在与调用函数将这个a[]视为了一个指针。函数参数表中的数组实际上是指针，但是可以用数组的运算符[]进行运算
    在函数参数表中 int sum(int *a, int n) 与 int sum(int a[], int n)是一致的
答：数组变量本身表达地址，所以    int a[10]; int *p = a;这里的a是不需要取地址符的
                                 但是数组的单元表达的是变量，这个时候读取每一个变量地址需要&
    []运算符可以对数组做，也可以对指针做，数组和指针之间是有关系的；*这个符号也可以对数组做，数组变量是const的指针
				 
问：指针与const有什么关系？指针本身是一种变量，而其中有两个东西，一个是指针本身，另一个是指针所指向的变量自身，而这两个都可以是const，所以这里面可能存在多种情况。
答：1、若指针是const，则代表该指针获得了某一个变量的地址，并且不能再指向其他变量了。例：int *const q = &i; //q是const，q的值就是指向i且值不可改变，但是i的值可以改变。
       *q = 26;//可以这样直接赋值 但 q++是错误的
    2、若所指是const，表示不能通过这个指针去修改那个变量（并不能使得那个变量成为const）。例：const int *p = &i; 则*p=26;//这个表达是错误的，都是可以写i=26;p=&j。可以进行这
       中重新赋值。i与p在这句话里面都是可以改变，但是不能通过p去做赋值。
    这两种情况的区分在于 const 到底是在*号前还是后。const 在*的后面表示指针不能被修改，在*前是第2种。
    我们总是可以将一个非const的值转变为一个const，例如：void f(const int*x); 这里就保证传入函数的参数不会对传入参数做改变。
    const int a[]={1,2,3,4,5} 数组变量本身就是const的指针了，这里再加一个const表明数组的每个单元都是const int，里面每个变量均为const，不能再改变的，必须通过初始化赋值。
    若需要保护数组不被函数破坏，则可以设置参数为const，例：int sum(const int a[])
    
问：数组的运算
答：给指针加1表示的是移到下一个变量，如果指针不是指向一片连续分配的空间时这种运算就没有意义。
    对指针可以做的运算：1、给指针加、减一个整数（+、+=、-、-=）；递增、递减；两个指针相减。指针不能做相减
                       2、 *p++：取出p所指的那个数据，完事之后顺便把p移到下一个位置去。*的优先级虽然高，但是没有++高，常用于数组类的连续空间操作，这个是两个语句的形成
		       3、指针比较：<,<=,>,>=,==,!=,都可对指针做，比较他们在内存中的地址。
		       
		    
问：数组和指针、普通变量和指针 他们之间的不同
答：#include<stdio.h>
    int main() 
    {
	int a = 1;
	int* p, * q;
	p = &a;
	q = a;
	printf("%p\n%p\n%d\n%p\n%d\n", &a,p,q,q,*p);

	int b[] = { 1,2,3,4,5 };
	int* p1, q1;                                //这里的指针和数组中可以看出，数组名就是数组的首地址，可以直接赋值给指针，但是若要获得数组里面的数据，需要[]运算符
	p1 = b;                                     //这里可以将其写为 int* p1 = b; 这样也是可以的。由此可以看出对于*，我们只是用其标志了这个变量是指针类型，我们可以
	q1 = b[0];                                    进行p的运算时带*或者不带。带*号时其是指里面的值，不带*号表示的是自己本身存储的地址值。
	printf("%p\n%d\n%d\n%d", p1, p1, q1, *p1);
	return 0;
     }
     实验结果：
     0000005F4D93F654
     0000005F4D93F654
     1
     0000000000000001
     1
     0000005F4D93F6B8
     1301542584
     1
     1
***********************************************************************************************************************************************************************
问：指针中常见搞混的情况
答：
int p; //这是一个普通的整型变量
int *p; //首先从P 处开始,先与*结合,所以说明P 是一个指针,然后再与int 结合,说明指针所指向的内容的类型为int 型.
          所以P是一个返回整型数据的指针
int p[3]; //首先从P 处开始,先与[]结合,说明P 是一个数组,然后与int 结合,说明数组里的元素是整型的,
            所以P 是一个由整型数据组成的数组
int *p[3]; //首先从P 处开始,先与[]结合,因为其优先级比*高,所以P 是一个数组,然后再与*结合,说明数组里的元素是指针类型,
             然后再与int 结合,说明指针所指向的内容的类型是整型的,所以P 是一个由返回整型数据的指针所组成的数组
int (*p)[3]; //首先从P 处开始,先与*结合,说明P 是一个指针然后再与[]结合(与"()"这步可以忽略,只是为了改变优先级),
               说明指针所指向的内容是一个数组,然后再与int 结合,说明数组里的元素是整型的.所以P 是一个指向由整型数据组成的数组的指针
int **p; //首先从P 开始,先与*结合,说是P 是一个指针,然后再与*结合,说明指针所指向的元素是指针,然后再与int 结合,
           说明该指针所指向的元素是整型数据.由于二级指针以及更高级的指针极少用在复杂的类型中,所以后面更复杂的类型我们就不考虑多级指针了,最多只考虑一级指针.
int p(int); //从P 处起,先与()结合,说明P 是一个函数,然后进入()里分析,说明该函数有一个整型变量的参数,然后再与外面的int 结合,
               说明函数的返回值是一个整型数据
Int (*p)(int); //从P 处开始,先与指针结合,说明P 是一个指针,然后与()结合,说明指针指向的是一个函数,然后再与()里的int 结合,
                 说明函数有一个int 型的参数,再与最外层的int 结合,说明函数的返回类型是整型,所以P 是一个指向有一个整型参数且返回类型为整型的函数的指针
int *(*p(int))[3]; //可以先跳过,不看这个类型,过于复杂从P 开始,先与()结合,说明P 是一个函数,然后进入()里面,与int 结合,说明函数有一个整型变量参数,
                     然后再与外面的*结合,说明函数返回的是一个指针,,然后到最外面一层,先与[]结合,说明返回的指针指向的是一个数组,然后再与*结合,说明数组里的元素是指针,
		     然后再与int 结合,说明指针指向的内容是整型数据.所以P 是一个参数为一个整数据且返回一个指向由整型指针变量组成的数组的指针变量的函数.

问：指针的类型
答：指针的类型是可以不一样的，这个具体是根据其地址指向的变量的类型决定的，但是所有的指针大小都是一样的，因为都是地址。但是指向不同类型的指针是不可直接相互赋值的

问：总结指针的作用
答：需要传入较大的数据时可以用其作为参数；传入数组后对数组做操作；函数返回不只只要一个结果时；动态申请的内存
***********************************************************************************************************************************************************************
问：动态内存分配
答：概念：若程序需要输入数据，先告诉个数，然后再输入，要记录每个数据。c99可以用变量定义数组大小，但是vs编译器还是不支持动态数组的情况，所以说要是在vs里面写代码，需要自定义
    也就是需要键盘输入数组大小时，还是老老实实用malloc语句。  int *a = (int*)malloc(n*sizeof(int))
    具体代码：
    #include<stdio.h>
    #include<stdlib.h>
    int main() 
    {
	int number, * a,i;
	scanf_s("%d", &number);
	a = (int*)malloc(number * sizeof(int));    //这个代码实现了可以输入数字然后形成该大小的数组
	for (i = 0; i < number; i++)               //这个是这句话的具体该如何写的说明，可变的
	{
		scanf_s("%d", &a[i]);
	}
	for (i = 0; i < number; i++) 
	{
		printf("%d ", a[i]);
	}
	free(a);                                  //这里一定要注意，是用来mallco后所形成的地址，使用完后必须的归还的，利用free
	return 0;                                   想malloc申请的空间大小是以字节为单位的，该malloc函数原本的返回类型是void*，可以转化为自己需要的
     }                                              在使用malloc时要注意在最上面写#inlcude<stdlib.h>
     输出结果：                                  //malloc是向系统申请空间
     3                                           // free()是与malloc相对应的函数，应该是把申请得来的空间还给系统，只能是还这一部分
     2 3 4
     2 3 4
***********************************************************************************************************************************************************************
字符串
1、C语言的字符串和字符数组是不一样的，两者的不同点在于：字符串在最后会放/0，从数组来看，数据会多加一个
2、字符串是以\0为结尾的一串字符，因此字符数组可以通过加上\0来变成字符串。\0标志着字符串的结束，但其并不是字符串的一部分，在计算字符串长度是不包含0的
3、C语言字符串以字符数组的形式存在于大脑中，以指针或数组来访问，不能用运算符对字符串做运算，得通过数组的方式可以遍历字符串
4、在使用字符串时，要写 #include<string.h>
5、字符串变量也是字符数组变量，表达形式： char *str = "hello;  char word[] = "hello";   char line[10]="hello"。这个时候“hello”是叫做字符串常量，其会被编译器编译为一个字符
   数组，长度为5+1。两个相邻的字符数组会被放到一起
6、唯一特殊的地方是字符串字面量可以用来初始化字符串数组
    
字符串变量
1、写字符串的形式有上面说过的两种： char *s=hello; 我们会说s是一个字符串。但是若是写s[0]='b'就会错误。这是因为s是一个本地变量，其和代码中的其他本地变量是在同一个地方的。其
   里面保存着地址，指向hello，但是hello不是放在本地变量位置的，hello是放在一个只读的小代码段，只能读不能写。所以说 这种写字符串的方式就不能够进行修改。若要进行修改，可以用
   int a[]来定义。
2、当我们需要字符串的时候，我们到底是选择指针还是数组？  当使用数组时，这个是代表着这个字符串就在本地变量一起的地方，会被自动回收的，要处理一个字符串就要用数组。
   但是使用指针的话，就不知道这个字符串在哪里，通常我们在函数参数处理、动态分配空间时，这个就是得用字符串。
   
字符串的输入输出
1、字符传使用 %s 输出格式进行。scanf在读输入的字符串时，读的是一个单词，当其独到回车、空格、\t的时候就暂停。对于这种的scanf是不安全的，因为不知道要读入的内容的长度，若空格
   或者其他标识符一直没来，就会溢出"。一个字符串接受到空格等符号后就结束，后面还有也不要了
2、针对上述问题，则需要告诉scanf有几个字符最多可读，这样会解决这个标识符会超过字符数组的情况。代码：scanf("%7s",string)
3、代码：char *string; 这个不是字符串类型，因为没有初始化，这个时候还是一个指针，只有初始化后令其指向字符串的地址后才能说其是字符串数组。
代码：
#include "stdio.h"
#include "stdlib.h"  //stdlib与string两个省略也是可以的
#include "string.h"
int main(void)
{
	char a[1000];
	int b[3]={2,3,4};

	scanf_s("%s", a, sizeof(a));               //在vs里面如果是想要输入字符串，需要在字符串后面再写上sizeof（字符串数组名），且注意到这里的a没有加&，当然加上&程序也可
	printf("%s\n%p\n%p\n%d\n", a, b, &b, b[0]);              //高版本的VS对代码的安全性要求越来越高，想要保证不会溢出。上面的sizeof的具体值并没有写上也可以运行
	return 0
}
输出结果：
hello
hello                                         //这里的输出结果表明，数组的名称就是首地址这个没问题
000000BCF84FF3E8  
000000BCF84FF3E8
2

字符串数组（若想要写一个数组来表达多个字符串呢？）
1、char **a; 表示a是一个指针，指向另一个指针，那个指针指向一个字符串。
   当用二维数组a[][]来表示一个字符串数组，则a[0]其实就代表char[10]。 char a[][10]与char *a是不一样的，第一个表示的是a[0]是一个字符串数组，而第二个表示的是a[0]是一个指针
***********************************************************************************************************************************************************************
字符串函数（在使用时必须写上#include<string.h>）
1、strlen，计算数组的长度的，使用格式：strlen（数组名）
2、strcmp，对比两个数组是否一致，甚至可以对比哪个更大，使用格式：strcmp（s1，s2）
3、strcpy，把第二个数组复制一份拷贝一个全新的给第一个，使用格式：strcpy（s1，s2），第一个参数是目的地，第二个是复制原，返回的是dst
   复制一个字符串：char *dst = (char*)malloc(strlen(src) + 1); strcpy(dst, src);
4、strcat，把s2拷贝到s1的后面，连接形成一个新的字符串，返回s1，使用格式：char *strcat(s1, s2);  strcpy与strcat都不太安全，都有带n的，可传入数据的个数，保证安全
5、strchr，在字符串找某个字符第一次出现的位置，返回的是指针，返回null表示没有找到。使用格式：strchr(s, 'l'); 这样找到的是s字符串里的第一个l，若要找第二个：strchr(p+1,'l')
   这里的p是返回的指针，指针加1
6、strstr，在字符串中寻找一个字符串；strcasestr，在字符串寻找一个字符串（忽略大小写的不同）。
***********************************************************************************************************************************************************************
枚举
1、枚举是一种用户定义的数据类型，也就是列举、排列说明的意思。枚举类型是C语言中的一种特殊类型，枚举类型可以让我们的程序使用一些固定长度和固定数值的变量值范围。
   它用关键字enum以如下语法进行声明：enum 枚举类型名字{名字0,...,名字n}; 枚举有int类型
2、枚举类型名字通常不使用，要用的是在大括号里的名字，因为它们就是常量符号，其里面的类型都是int，值则从0开始依次递增到n。
3、例：enum colors{red, yellow, green}; 这里就创建了3个常量，其中red是0，green为2。同时枚举量的值也是可以指定的。
4、当需要一些可以排列起来的常量值时，定义枚举的运用就是给了这些常量值名字。在枚举当中有常用的小套路，参考翁恺老师视频课
***********************************************************************************************************************************************************************
结构类型
1、一个结构就是一个复合的数据类型，在里面可以有很多不同的成员。把一些关联的数据存放在一起，这样方便我们使用，但是这些数据的类型有时候并不一致这就可以用一个变量来表达多个数
   据。结构类型定义完后一定要记得再加上分号。
   结构类型定义格式：
   struct 结构体类型名
   {
       成员表列
   };
2、和本地变量意义，在函数内部声明的结构类型只能在函数内部使用，所以通常在函数外部声明结构类型，这样就可以被多个函数使用了。则可以在任何函数内使用。
3、定义与使用
   struct point
   {
      int x;
      int y;
   };
   struct ponit p1,p2;       //在使用时必须得写上是struct point，这两个统称类型名，p1是变量名
4、当有了一个结构变量时，我们可以访问这个结构变量里的成员变量，这里是用运算符.来访问成员。例：p1.x   结构体变量名.成员名
5、结构变量初始化：struct date today = {07, 31, 2014}; 或者 struct date tomorrow = {.mouth=7, .year=2014}这里只声明了我们两个，未被声明的内容就视为0.
6、结构体的运算：*用结构变量的名字直接访问整个结构。*对于整个结构，可以做赋值、取地址、也可以传递给函数参数。可以直接写 p1 = p2;  结构和数组是很不一样的
7、与数组不同，结构变量的名字并不是结构变量的地址。所以说对数组名取不取&都是一样的，因为都是地址，都是结构变量必须加&才能取地址。
***********************************************************************************************************************************************************************
结构与函数
1、结构变量作为函数参数写在参数列表中，例：int numberofdays(struct date d);  整个结构是可以作为参数的值传入函数的，这个时候是在函数内新建了一个结构变量，并复制了调用者的
   结构的值，这个与数组不一样。所以说在函数中改变了结构内的值，若不将此改变后的值再传入main中则结果是无效的。
2、在自由输入结构变量里面，语句 &today. month中，这个&的运算符的优先级要低于. 的。
3、在结构与函数里面，我们更好地是将结构指针作为参数。若是传结构本身过去的话，则还需要一个一个复印里面的值，不划算。
4、指向结构的指针： struct date *p = &myday; (*p).month = 12; 第二句话也可以写作 p->month = 12; *p是代表myday

结构中的结构、数组中的结构、
1、结构类型的数组（结构数组）：也就是每个数组是。一个结构体，例如：struct date dates[100] = {{4,5,2005},{2,4,2001}}; //这里要多一个大括号在外面，用来及数组的个数在里面
   这个时候要读出时：结构变量名.具体类型名。并且在printf的时候输出字符为 %i .
2、结构中的结构：在定义的结构里，其中的数据类型还是结构。
   例如：struct point
	       {
				    int x;
						int y;
				 };
				 struct rectangle
				 {
				    struct point pt1;
						struct point pt2;
				 }r;
				 则就有：r.pt1.x 和 r.pt1.y //在.这个运算符的左边必须是一个结构体变量
				 若有定义：struct rectangle *rp;
				           rp = &r;
				 则以下四种形式是等价的：
				           r.pt1.x
									 rp->pt1.s //这两种形式再在前面分别加上括号
3、结构中的结构的数组
   接上面所阐述的例子
	 我们这里再对组成一个以struct retangle为元素的数组。例如：struct rectangle rects[]={{{1,2},{3,4}}}  
	                                                  //这里有三组括号，最外层的大括号表示的是数组的大括号，第二层的大括号表达的是数组的单元，也就是结构，第三层是point里的
4、自定义数据类型（typedef）
  * typedef用来声明一个已有数据类型的新名字。例如： typedef int length; 这就意味着我们使得length成为int类型的别名。则 length a,b,len; 这样的语句就都是正确的。
  * 则我们可以用新的名字来命名某种类型，使得类型更加地可读。例如：typedef struct date date; //这个时候原本在构建新变量的时候必须写做的struct date就可以只写做 date了。
    但是注意，我们这里命名为新的名字的时候，这个名字一定是只有最后的一个单词	
	
	

***********************************************************************************************************************************************************************
//函数的一些知识点
1、函数的递归：函数是C语言的模块，有较强的独立性，可相互调用。可在函数A中调用函数B，也可在函数B中调用函数C，调用函数自身称为递归。
2、main函数是整个程序的入口，因此我们一般将编写的函数放在后面，将main放在前面，但是我们这样是需要将其进行声明。
3、 C语言为我们提供了上百个可调用的库函数，例如与字符串有关的strlen,strcat,strlwr，或是我们刚接触C语言时候用到的printf,scanf,这些都是c语言为我们提供的。
    在我们使用某一库函数的时候，需要在程序中嵌入(#include<>) 该函数所需要的头文件。
    因此我们在代码开头都需要写上#include <stdio.h>，因为 printf, scanf，getchar,gets,putchar()这些函数 (也称作标准I/O函数)，都是在stdio头文件中。
4、函数按照是否有参数分为有参类型和无参类型，按照是否有返回值也分为有返回值和无返回值两种类型。
5、有参与无参区分：有参函数：在该函数被调用的时候，主调函数通过参数向里面传递了数据；无参函数：不传递数据，因没有参数，无法获得值。

函数的定义和声明
1、形式 :
       函数类型   函数名(参数表)
       参数说明
       {
           数据说明
           执行语句
       }
2、函数调用
调用函数的时候，需要知道以下几点：
  1：在调用的时候，主调函数向参数传递的是值，在调用结束后，该值不改变。
     函数再调用的时候，发生的是值传递，也就是把值拷贝一份给形参，在形参里面改变这一数值，即在调用函数中改变数值，并不影响实参的值（这里的值是单向传递的：实参 -> 形参）
  2：函数只有被调用，系统才会给它分配内存单元。
  3：调用结束后，系统给他分配的内存单元立即被释放，而主调函数中的值不会改变
  4：主调函数传递给被调用函数值后，被调用的函数里面可以直接用该值，但是要记住，值的数据类型要和参数的数据类型一一对应。
     在数据传递的时候，若是数据类型不同，有可能会发生数据丢失等错误，调用函数时给的值与参数的类型必须匹配。
  5：可以彻底给被调函数的值是表达式的结果，包括：字面量、变量、函数的返回值、计算的结果。
  6：函数调用时有两种方式：传值调用 与 传址调用（在某些情况下我们要使用不同的方法，例子见其下）
3、函数知识点编写时发现的点
***********************************************************************************************************************************************************************
3.1
#include<stdio.h>
int max(int a,int b)               //这里是编写的求取max的函数，注意我们需要将求得的值返回给main函数，因此这里是要设定函数类型为int，不能为void
{
        int max;                  //从中可看出在这里其实也是可以再定义变量的，在函数头列出的是main传给该函数的参数表，是用来计算的值在这里体现，
	if (a >= b)                 但是在实际的函数运行中所使用别的变量也是可以再定义的
	{
		 max = a;         //这里更为简便的方法是直接传递a的值过去即可，不需要在进行一次max的赋值，else处也是
		return max;
	}                         //这个函数max中的参数是两个int形的变量，若是编写的函数是无参数时，则括号里应写void，若括号里
	else                        什么都不写代表的是这个函数的参数未知，不表示没有参数。参数表里的都好是标点符号，不是运算符号
	{
		 max = b;         //C语言中可以允许函数嵌套使用，但是不允许函数嵌套定义
		return max;
	};
}
int main(void)
{
	int a=max(4,6);          //定义时直接顺便赋值
	printf("%d", a);
	return 0;
}
***********************************************************************************************************************************************************************
3.1返回值return
#include<stdio.h>
void swap(int a, int b);            //从结果可知a与b并没有交换   
int main() 
{
	int a = 5;
	int b = 6;
	swap(a, b);
	printf("a%d,b%d", a, b);
	return 0;
}
void swap(int a, int b)             //这里函数设为void形式，没有返回值return
{                                    1、return 语句的一般形式为：return （表达式） 有无括号都是正确的
        int x = a;                   2、没有返回值的函数为空类型，用void表示
	a = b;                             3、return 语句可以有多个，可以出现在函数体的任意位置，但是每次调用函数只能有一个 return 语句被执行，所以只有一个返回值。
	b = x;                             4、函数一旦遇到 return 语句就立即返回，后面的所有语句都不会被执行到了。return 语句还有强制结束函数执行的作用。
}                                    5、这个交换数据的题目，对应了调用函数的第一点，发生值传递时，我们是将数值拷贝一份给调用函数内，在调用函数内改变数据，不会影响实参的
结果：a5，b6                            数值的，因此这里并没有交换
                                     6、其次在该代码中，在main中我们已经使用过名字为a、b的变量了，但是又可以在swap函数中再次使用

***********************************************************************************************************************************************************************
3.2 传值与传址（函数两种传递方式）（传址的含义在我们学完数组后可以进行，我们需要先学习完地址的概念）
    传值：每个函数有自己的变量空间，参数也位于这个地理的空间中，与其他函数没有关系，由此引入本地变量的概念
    本地变量：函数的每次运行就会产生一个独立的变量空间，在整个空间中的变量，是函数这次运行所独有的，称作本地变量。定义在函数内部的变量就是本地变量
    变量的生存期：什么时候该变量出现了，到什么时候整个变量消失了（在括号内，块）
    变量的作用域：在什么范围内可以访问整个变量，整个变量可以起到作用（在大括号内，块）
    代码编写点：因此我们在有的部分需要验证代码的输出时会用到大括号来。
    本地变量规则：+本地变量是定义在块内的，可以是定义在函数、语句、大括号的块内；
                  +程序运行时进入这个块之前，其中的变量是不存在的，进入块时变量存在，离开这个块时，变量消失
		  +块外面定义的变量在里面仍有效
		  +块里面定义了和外面同名的变量则掩盖了外面的变量，但是不能在一个块内定义同名变量
		  +本地变量不会默认初始化，在参数进入函数之前就必须已经完成初始化了		  

***********************************************************************************************************************************************************************
数组知识
1.数组定义：数组是用来存储一系列相同类型数据的集合
            静态数组内存分配是连续的（即地址连续）,最低的地址对应首元素，最高的地址对应末尾元素。
	    在栈内存上分配了固定大小，在运行时这个大小不能改变。在函数执行完以后，系统自动销毁。
2.一维数组的定义和初始化.
  定义格式：   类型名 数组名[常量表达式]  例如：int a[3]; //这里a是数组名，同时也是数组首因素地址，3为数字内数的个数
  
  个人理解：数组在计算机内规定了一块区域用来存储一组数，这里面所存储的数的种类及存储地方都是一样的，数组名是这个数组的首地址
  C语言数组的下标都是从0开始的；
  在定义数组时不能使用变量定义数组的大小，如果前面没有对n进行宏定义 #define n 5，则a[n]则不对，因为n不是一个确定的数;
  在对数组定义时，不要让数组下标越界访问；
  在初始化时可以进行完全初始化，即每个都进行正常赋值，也可以进行不完全初始化，则没被赋值的部分会被定义为0；
  不能定义了一个数组却不初始化；
  集成初始化时的定位：若要特殊指定数组中的某几个位置上的数，则用[n]在初始化数据时给出定位
  数组中第一个索引值为 0；
  长度为n的数组，最后一个元素的索引值为n - 1,若输入a[n]则会报 “数组越界错误”；
  不能在方括号中用变量来表示元素的个数， 但是可以是符号常数或常量表达式；
  数组名就是首地址。
3.
***********************************************************************************************************************************************************************
数组代码中获得的知识点
1、输入一组数据，求和取平均，并将该组数据与平均数对比大小，输出比其大的。输入这组数据后碰到-1就算结束
1.1这里是一开始的输入数组并且遍历输出
#include <stdio.h>
int main()
{
    int i=0, x;
    int a[3];          //数组不是必须在一开始就进行初始化，但是这个时候里面的数是乱码
    
    scanf_s("%d", &x);
    while (x != -1)    //mad，这是循环跳出的结果啊，你不输出-1，代码咋给你跳出啊，白痴了不是
    {
        a[i] = x;      //这里需要先判断该数值是否为-1再进行输入到数组内，要先进行判断
        i++;
        scanf_s("%d", &x); //这里也是玄幻的一部分，当scanf_s中只有一个%d的时候是只输入一个值的，所以得重复输入语句
    }
    for (i = 0; i < 3; i++)
    {
        printf("%d ", a[i]);
    }
    return 0;              //这一次的代码就是写入数组，然后在逐个输出
}

1.2此处为输入数组后再求取平均值并且比较大小，小于等于的再次输出
#include <stdio.h>
int main()
{
    int i = 0, x, sum = 0, number = 0;
    int a[10];          //数组不是必须在一开始就进行初始化，但是这个时候里面的数是乱码
    
    scanf_s("%d", &x);
    while (x != -1)    //mad，这是循环跳出的结果啊，你不输出-1，代码咋给你跳出啊，白痴了不是
    {
        a[i] = x;
        sum += a[i];      //这里需要先判断该数值是否为-1再进行输入到数组内，要先进行判断
        i++;
        number++;
        scanf_s("%d", &x); //这里也是玄幻的一部分，当scanf_s中只有一个%d的时候是只输入一个值的，所以得重复输入语句
    }                      //数组已输入了，这里再进行求和了
    i = 0;
    printf("平均数=%.2lf\n", 1.0*sum / number);
    while (i<number)               //一开始是直接进行了while的循环，判断条件是a[i]>=sum/number，这个就不对
    {                              //首先我们是需要遍历整个数组，要确认我们需要循环的究竟是什么，然后对数组的数进行判断
        if (a[i] <= sum / number)  //其次，这个循环条件一开始写的是i<=number;这样会出现错误项，i作为数组的下标，是只到number-1的
        {                            若写等于number则会导致读取数值会超过数组范围，出现错误答案
            printf("%d ", a[i]);
        }
        i++;
    }
    return 0;
}

1.3上述代码是初始化数组就是100个数，这里也是有危险的，万一数组的数超过100就难受了，所以代码还可以改进，所以这里我们可以在前面提前输入判断这个数字到底有几个数字，然后做数组
   后续还有需要

2、写一个程序，输入数量不确定的[0,9]分为内的整数，统计每一种数字出现的次数，输入-1时表示结束

#include <stdio.h>
int main()                      //在写程序之前要判断清楚题目要求的内容，分清哪些需要，哪些不用，这道题就不需要把每个数字记录下来
{                               
    int a[10] = { 0 };          //未经定义时这里面就全都是乱码的数字
    int x,i;                    //一开始说过了，数组在定义时个数是不能是个变量的，不能是个未知量，但是在使用的时候不一定

    scanf_s("%d", &x);
    while (x != -1) 
    {
        if (x >= 0 && x <= 9)
        {
            i = x;
            a[i]++;             //这里我们可以视为中国数字名为一个变量，变量的值初始为0
        }
        scanf_s("%d", &x);      //这里切记不可忘记这个循环输入的语句，对于这种需要判断且逐个输入的值，必须得重复这一句
    }
    for (i = 0; i <= 9; i++)    //这里i已经在上面运算中获得过值，但是不影响下面这里它重新被使用再复制
    {
        printf("%d ", a[i]);
    }
    return 0;
}


#include <stdio.h>
int main()                                   //在上面的基础上我们还需要保存上面输入记录的数
                                             //这个时候就需要重新定义一个数组，这个a这个已经用来存数字
{                                            //这个代码在前一个的基础上将输出更加规范了，将输入数字可以记住了
    int b[100], x, i, number = 0;
    int a[10] = { 0 };
    scanf_s("%d", &x);
    while (x != -1) 
    {
        b[number] = x;
        number++;
        if (x >= 0 && x <= 9)
        {
            i = x;
            a[i]++;
        }
        scanf_s("%d", &x);      //这里切记不可忘记这个循环输入的语句，对于这种需要判断且逐个输入的值，必须得重复这一句  
    }    
    for (i = 0; i <= 9; i++)    //这里i已经在上面运算中获得过值，但是不影响下面这里它重新被使用再复制
    {
        printf("%d=%d ", i,a[i]);
    }
    return 0;
}


3、在一组给定的数组中，如何找出某个数据是否存在？

3.1我自己的代码
#include <stdio.h>
int main() 
{
    int a[] = { 2,4,6,7,1,3,5,9,11,13,23,14,32 };
    int x, i = 0;

    scanf_s("%d", &x);
    for (i = 0; i < 13; i++)                       //这里循环继续的条件仍是不用加=的
    {
        if (x == a[i])                             //这里在写判断语句条件时还是将符号写错了
        {
            printf("a[%d]=%d\n",i, a[i]);
        }
        i++;
    }
    return 0;
}

3.2老师的代码
#include <stdio.h>
int search();                                      //这里也是没有写函数里面的参数，但是能够正常编译及运行，验证了在函数学习中的知识
int main()                                         //在上面的基础上我们还需要保存上面输入记录的数，这个时候就需要重新定义一个数组，这个a这个已经用来存数字
{
    int a[] = { 2,4,6,7,1,3,5,9,11,13,23,14,32 };
    int x, loc;

    scanf_s("%d", &x);
    loc = search(x, a, sizeof(a) / sizeof(a[0]));
    if (loc != -1) 
    {
        printf("a[%d]=%d\n", loc, x);
    }
    else 
    {
        printf("no\n");
    }
    return 0;
}
int search(int key, int a[], int length)           //此处一开始没有加上[]符号，则hi认定a为一个int的变量，而非数组，就会使得下面if判断报错
{
    int ret=-1;                                    //ret就是reaction的缩写，用于返回值的代替
    int i;
    for (i = 0; i < length; i++) 
    {
        if (key == a[i]) 
        {
            ret = i;
            break;                                //break前面学过，是用于跳出整个循环，continue是跳出此个小循环再执行剩下的循环
        }
    }
    return ret;                                   //这里的返回值也很巧妙，这里的ret是有两种返回情况在，明确一点是ret返回值是只能返回一个数
}                                                 //但是我们可以设定不同的值来进行判断的

4、判断素数
 4.1 代码遍历2——n-1，一个一个地除下去，来判断其是否有公因数，但这种计算的次数很多且花费时间大
 4.2 改进：出了2以外的偶数都不是素数，因此只用判断奇数。在判断某一个奇数时，我们的除数不再+1了，而是+2。因为剩下的素数都是奇数，而奇数的因数里面一定不可能有偶数
           一个数若那个被偶数整除，则这个数一定是偶数，因此我们在这里把所有的偶数去掉，只判断奇数因数。
     #include<stdio.h>
int main() //判断素数
{
	int number, i, isprime = -1;

	scanf_s("%d", &number);
	if (number == 1 || number % 2 == 0 && number != 2) 
	{
		isprime = -1;
	}
	for (i = 3; i < number; i += 2) 
	{
		if (number % i == 0) 
		{
			isprime = 1;
		}
	}
	if (isprime == 1) 
	{
		printf("yes\n");
	}
	else 
	{
		printf("no\n");
	}
	return 0;
}
写成整个函数形式
#include<stdio.h>
int isprime();                   //写成函数形式的还是有些不太熟悉，需要加强
int main() 
{
	int number, i;
	scanf_s("%d", &number);
	i = isprime(number);
	if (i == 1) 
	{
		printf("yes");
	}
	else 
	{
		printf("no");
	}
}
int isprime(int x)
{
	int ret = 1;                   //这里一开始就是判断其为素数，将不是素数的形式一一去掉的
	
	if (x == 1 || x != 2 && x % 2 == 0) 
	{
		ret = 0;//不是素数
	}
	for (int i = 3; i < x; i += 2) 
	{
		if (x % i == 0) 
		{
			ret = 0;
		}
	}
	return ret;
}
 4.3可以将671行中循环继续的i < x语句改为 i < sqrt(x) ，这样又会节省循环次数
 4.4改进再次使得代码运行更快，前面我们说到 ++ 改为 +2，因为一个数若能被偶数整除则其一定是偶数，则奇数一定没有偶数公因数。
    由此可知，一个数若不能被2整除，则其一定无法被2的倍数整除；同理，若一个数不能被3、5整除，则也不可被其倍数整除  **********************************
    所以，如果整数x无法被小于x的质数整除，那么x就是质数。                **********************************
    根据这个条件，求质数就有了另外一条思路：用数组来保存质数，控制x自增后，用x除去数组的每一个元素，如果不能整除则是质数，并且保存到数组中。
    
#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>
int main()
{
	int arr[500] = { 2, 3 };    //定义数字为500大小
	int x = 0;
	int i = 0;
	unsigned int count = 0;
	int sum = 2;  //定义数组的下标
	for (x = 5; x < 1000; x += 2)
	{
		//从下标0开始遍历，直到数组的最后一个质数
		for (i = 0; i < sum; i++)
		{
			count++;
			if (x % arr[i] == 0)
			{
				break;
			}
		}
		if (sum == i)  //遍历后都不能整除
		{
			arr[sum] = x;  //把质数保存到数组中
			sum++;   //下标加1，为下次放做准备
		}
	}
	for (i = 0; i < sum; i++)
	{
		printf("%d ", arr[i]);
		if ((i + 1) % 5)
		{
			printf("\t");
		}
		else 
		{
			printf("\n");
		}
	}
	printf("\n\n\n");
	printf("运算的次数：%d ", count);
	return 0;
}


 4.5**************************知识点：在vs里面定义变量为常量时不能用 const 语句，得用define语句

const int maxn = 10;    //C程序报错
int a[maxn];            //error:variably modified 'a' at file scope   

解释：可以在c++里面这么写，但是在C语言里面不可以
      常量 与 只读变量 (不可变的变量）的区别：常量 肯定是只读的，例如数字6， 字符串“abc”等，肯定是只读的，因为程序中根本没有地方存放它的值，当然也就不能够去修改它。
                                             只读变量 则是在内存中开辟一个地方来存放它的值，只不过这个值由编译器限定不允许被修改。
                                             C语言规定数组定义时下标必须是常量，只读变量是不可以用的。
      C语言中，const 就是用来限定一个变量不允许被改变的修饰符，即只读变量，因为占有存储空间，所以编译器不知道编译时的值，所以就不知道该给数组定义多大的。
      
所以在C语言中要这样定一个数时，是需要用全局宏定义的，下面这种可以的
#include<stdio.h>
#define number 3
int main() 
{
    int a[number];
}

