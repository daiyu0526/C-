//C语言学习练习题中的值得记录知识点

// 1.求解1-1/2+1/3-...+1/n

#include<stdio.h>
int main(void)
{
	double sum = 0.0;            //浮点型在初始化时，数字需带上小数点来表示
	int i,number, sign = 1;

	scanf_s("%d", &number);
	for (i = 1; i <= number; i++)
	{
		sum += sign * 1.0 / i;       //这里i为整形数据，但前面都是浮点型数据，再进行整型转化至浮点型时常用乘1.0
                sign = -sign;                //题目这里的变号比较巧
	}
	printf("sum=%f\n", sum);
	return 0;
}







//2.正序地分解整数 例：输入12345；输出：1 2 3 4 5

#include<stdio.h>
int main(void)
{
	int number, d = 0, ret = 0,b=0;

	scanf_s("%d", &number);
	do 
	{
		d = number % 10;
		number = number / 10;
		ret = ret * 10 + d;
	} while (number > 0);
	printf("%d", ret);
	printf("\n");                   //这个代码将数进行一次倒序
	                                //而后在下一个while循环中进行倒序逐个输出，可得最终结果
	do                              //这里是一个替代转向思维，有的无法直接解决的问题，我们可用别的问题再转换
	{                               //但这个问题无法将700转化为007
		b = ret % 10;           // **在if语句中经常将这个赋值符号=与判断符号==搞混
		printf("%d", b);
		if (ret > 9) 
		{
			printf(" ");
		}
		ret = ret / 10;
	} while (ret > 0);
	printf("\n");

	return 0;
}                        


//针对上述问题中无法适用于末尾有0的数字，则对上述代码再次实行更改

#include<stdio.h>
int main(void)
{
	int number, base = 1, d = 0, x = 0;                                //这里包含了两个部分 数整数位数+正序输出  有很多问题都是由小的问题进行组合解决的
	scanf_s("%d", &number);                                            //数位数是为了能够形成，例如：54321，得到：10000，再除再取余可进行
	x = number;                                                        
	if (number == 0)                      //在进行if语句判断时经常将==与赋值的=搞混
	{
		base = 0;                     //0是一个一位数，因此这里单独列出
		printf("base=%d\n", base);
	}
	else
	{
		while (number > 9)            //************number的不断条件是大于9，不是大于0，若是大于0，则会出现number=700，base=1000的情况
		{
			number = number / 10;
			base *= 10;           //************
		}
		printf("base=%d\n", base);
	}                                     //以上这里都是数整数位数的地方，同时得到了进制基数
	
	do                                    //这里是进行了整数顺序输出，这里也可以用while不用do—while
	{
		d = x / base;                 //这里得到正的第一位数
		printf("%d",d);               //输出
		if (base > 9)                 //这里将整数的每一位都分开
		{
			printf(" ");
		}
		x %= base;
		base /= 10;                   
	} while (base > 0);
	printf("\n");
	return 0;	
}







//计算机在计算一些基础问题时常爱用枚举法
//scanf_s在输入多个数字时，代码中可以不用空格隔开，可以写成scanf_s("%d%d", &u, &v); 但在输入时只能用空格隔开
//3.计算最大公约数 **************这里是枚举法

#include<stdio.h>                              //这是我的代码，这里也是运用到之前学的小方法来设置了一下变量
int main(void)                                 //这个没设最小值，但是运用了&&符号也可以保证t不会大于两个数中的任意一个
{
	int u, v, t = 2, x = 0;
	scanf_s("%d%d", &u, &v);
	while (u >= t && v >= t) 
	{
		if (u % t == 0 && v % t == 0) 
		{
			x = t;
		}
		t++;
	}
	if (x == 0)
	{
		printf("两个数无最大公约数");
	}
	else
	{
		printf("最大公约数%d", x);
	}
	return 0;	
}

#include<stdio.h>                               //老师的代码，运用了for循环且判断语句用if执行
int main(void)
{
	int u, v, min, i, ret;
	scanf("%d%d", u, v);
	if (u > v)
	{
		min = u;
	}
	else
	{
		min = v;
	}
	for (i = 1; i < min; i++) 
	{
		if (u % i == 0) 
		{
			if (v % i == 0) 
			{
				ret = i;
			}
		}
	}
	printf("%d", ret);
	return 0;	
}

//************以上两种方法效率低，所以这里用辗转相除法
//************辗转相除法的原理：又称欧几里得算法，是求取最大公约数的一种算法。核心原理：两个数的最大公约数等于其中较小的数字和二者之间余数的最大公约数
//************具体做法：用较小数除较大数，再用出现的余数（第一余数）去除除数，再用出现的余数（第二余数）去除第一余数，如此反复，直到最后余数是0为止。
                        如果是求两个数的最大公约数，那么最后的除数就是这两个数的最大公约数。整数在「加减乘」这三种运算下是封闭的
//************辗转相除法的具体证明查网络，gcd是最大公约数的缩写

#include<stdio.h>
int main(void)
{
	int a, b, t;
	scanf_s("%d%d", &a, &b);
	do
	{
		t = a % b;
		a = b;
		b = t;
	} while (b != 0);
	printf("%d", a);
	return 0;	
}








//4.给定不超过6的正整数a，考虑从a开始的连续4个数字，输出所有由其组成的无重复数字的3位数
//************格式要求：输入为2  输出为 234 235 243 245 253 254
                                        324 325 342 345 352 354  
					.....
					.....
#include<stdio.h>
int main(void)
{
	int a, i, j, k, n = 0;

	scanf_s("%d", &a);
	i = a;
	while (i <= a + 3) 
	{
		j = a;
		while (j <= a + 3) 
		{
			k = a;
			while (k <= a + 3) 
			{
				if (i != j) 
				{
					if (i != k) 
					{
						if (j != k) 
						{
							printf("%d%d%d ", i, j, k);
							n++;
							if (n % 6 == 0) 
							{
								printf("\n");
							}
						}
					}
				}
				k++;
			}
			j++;
		}
		i++;
	}
	return 0;	
}
//**************重点这里设置了三重循环用于不断地递增获得重组数字，但该遍历会出现重复数字的情况，因此
//**************这里加上了三个if语句用于消除这个问题，这种遍历与枚举是计算机最擅长做的事情。
//**************同时，此例也可以用if语句来书写，两个代码的对比可以看出while和for在相互转换时的方式

#include<stdio.h>
int main(void)
{
	int a, i, j, k;

	scanf_s("%d", &a);
	for (i = a; i <= a + 3; i++) 
	{
		for (j = a; j <= a + 3; j++) 
		{
			for (k = a; k <= a + 3; k++) 
			{
				if (i != j && i != k && j != k) 
				{
					printf("%d%d%d ", i, j, k);       //************从这里可以看出for函数的三个关系式是如何用，详见笔记
				}
			}
		}
	}
	return 0;	
}





//5.浮点数的精度确定

#include<stdio.h>
int main(void)
{
	printf("%.3f\n", -0.0049);
	printf("%.30f\n", -0.0049);
	printf("%.3f\n", -0.00049);
	return 0;
}
输出结果：                         //重点：这里可以看出对于浮点数，计算机没有办法到达像整数那样的精度，只能找到一个近似的数
-0.005                            //同时，double有十七位有效数字，则在17位开外的数字的有效性是不一定的。但在执行窗口处我们一般只显示小数点后6位，需要更多在printf里写
-0.004899999999999999841793218991
-0.000

